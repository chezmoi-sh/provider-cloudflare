//nolint:errcheck,gocritic,gocyclo,musttag
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

var (
	// Go template used to generate all configurations files required by the toolchain
	// to generate the Crossplane provider.
	tmplProviderConfig = template.Must(template.New("config").Funcs(template.FuncMap{
		"extractReference": func(ref string) (struct{ APIGroup, Name, Field string }, error) {
			matches := rxReferencePattern.FindStringSubmatch(ref)
			if matches == nil {
				return struct{ APIGroup, Name, Field string }{}, fmt.Errorf("invalid reference pattern: %s", ref)
			}
			return struct{ APIGroup, Name, Field string }{
				APIGroup: matches[1],
				Name:     matches[2],
				Field:    matches[3],
			}, nil
		},
		"fail_if_empty": func(format string, args ...any) (any, error) {
			if len(args) == 0 {
				return "", fmt.Errorf("invalid number of arguments: at least two are required")
			}

			target := args[len(args)-1]
			if reflect.ValueOf(target).IsZero() {
				return "", fmt.Errorf(format, args[:len(args)-1]...)
			}
			return target, nil
		},
	}).Parse(`
{{- range $ag_name, $resources := .Resources }}
---
// Code generated by scripts/generate_provider_config.go; DO NOT EDIT MANUALLY.
package {{ $ag_name }}

import "github.com/crossplane/upjet/pkg/config"

// Configure adds configurations for {{ $ag_name }} group.
func Configure(p *config.Provider) {
	{{- range $r_name, $opts := $resources }}

	// {{ $.PackageName }}/apis/{{ $ag_name }}/v1alpha1.{{ $opts.Kind }}
	p.AddResourceConfigurator("{{ $r_name }}", func(r *config.Resource) {
		r.Kind = "{{ $opts.Kind }}"
		r.ShortGroup = "{{ $ag_name }}"
		
	{{- with $opts.References }}{{ range $f_name, $ref := . }}
		{{- $ref := extractReference $ref }}
		{{- $_ := index $.Resources $ref.APIGroup | fail_if_empty "API group '%s' not found" $ref.APIGroup }}
		{{- $_ := index (index $.Resources $ref.APIGroup) $ref.Name | fail_if_empty "resource %s.%s not found" $ref.APIGroup $ref.Name }}
		{{- $_ := (index (index $.Resources $ref.APIGroup) $ref.Name).Kind | fail_if_empty "resource %s.%s has no kind defined" $ref.APIGroup $ref.Name }}

		r.References["{{ $f_name }}"] = config.Reference{
			TerraformName: "{{ $ref.Name }}",
			RefFieldName: "{{ $ref.Field }}",
		}
	{{ end }}{{ end }}
	})
	{{- end }}
}
{{- end }}
`))
	tmplExternalNameConfig = template.Must(template.New("config").Parse(`
// Code generated by scripts/generate_provider_config.go; DO NOT EDIT MANUALLY.
/*
Copyright 2022 Upbound Inc.
*/

package config

import "github.com/crossplane/upjet/pkg/config"

// ExternalNameConfigs contains all external name configurations for this
// provider.
var ExternalNameConfigs = map[string]config.ExternalName{
	{{- range $ag_name, $resources := .Resources }}
	{{- range $r_name, $opts := $resources }}
	"{{ $r_name }}": config.IdentifierFromProvider,
	{{- end }}
	{{- end }}
}

// ExternalNameConfigurations applies all external name configs listed in the
// table ExternalNameConfigs and sets the version of those resources to v1beta1
// assuming they will be tested.
func ExternalNameConfigurations() config.ResourceOption {
	return func(r *config.Resource) {
		if e, ok := ExternalNameConfigs[r.Name]; ok {
			r.ExternalName = e
		}
	}
}

// ExternalNameConfigured returns the list of all resources whose external name
// is configured manually.
func ExternalNameConfigured() []string {
	l := make([]string, len(ExternalNameConfigs))
	i := 0
	for name := range ExternalNameConfigs {
		// $ is added to match the exact string since the format is regex.
		l[i] = name + "$"
		i++
	}
	return l
}
`))

	// Regular expression extracting parts from the reference pattern (group/name→field)
	rxReferencePattern = regexp.MustCompile(`^(?P<group>.+)\.(?P<name>[^.→]+)→(?P<field>.+)$`)
)

func main() {
	log.SetFlags(log.Ltime)

	// Step 0 - Configure flags
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s -version <version> < JSON\n", path.Base(os.Args[0]))
		flag.PrintDefaults()
	}
	var providerVersion, xpPackage string
	flag.StringVar(&providerVersion, "version", "", "version of the Terraform provider")
	flag.StringVar(&xpPackage, "package", "github.com/chezmoi-sh/provider-cloudflare", "package of the Crossplane provider")
	flag.Parse()

	if providerVersion == "" {
		fmt.Fprintln(os.Stderr, "Error: version is required")
		flag.Usage()
		os.Exit(1)
	}
	if xpPackage == "" {
		fmt.Fprintln(os.Stderr, "Error: package is required")
		flag.Usage()
		os.Exit(1)
	}

	// Step 1 - Extract all defined resources and their references from STDIN
	var resources struct {
		PackageName string `omitempty:"true"`
		Resources   map[string]map[string]struct {
			Kind       string            `json:"kind"`
			References map[string]string `json:"references"`
		} `json:"supported"`
		Deprecated   []string `json:"deprecated"`
		NotSupported []string `json:"not_supported"`
	}
	if err := json.NewDecoder(os.Stdin).Decode(&resources); err != nil { //nolint:musttag
		log.Fatalf("invalid JSON input: %v", err)
	}
	resources.PackageName = xpPackage

	// Step 1.2 - Extract all defined resources
	resourceList := make(map[string]struct{})
	for _, resources := range resources.Resources {
		for name := range resources {
			resourceList[name] = struct{}{}
		}
	}
	for _, name := range resources.Deprecated {
		if _, ok := resourceList[name]; ok {
			log.Fatalf("resource '%s' must be in only one category: supported, deprecated, or not supported", name)
		}
		resourceList[name] = struct{}{}
	}
	for _, name := range resources.NotSupported {
		if _, ok := resourceList[name]; ok {
			log.Fatalf("resource '%s' must be in only one category: supported, deprecated, or not supported", name)
		}
		resourceList[name] = struct{}{}
	}

	// Step 2 - Check if some resources are missing
	// Step 2.1 - Fetch the list of official resources for the Terraform provider
	url := fmt.Sprintf("https://api.github.com/repos/cloudflare/terraform-provider-cloudflare/git/trees/v%s?recursive=true", providerVersion)
	resp, err := http.Get(url) //nolint:gosec,noctx
	if err != nil {
		log.Fatalf("resource list for cloudflare/terraform-provider-cloudflare (v%s) is not fetchable: %v", providerVersion, err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
	case http.StatusNotFound:
		log.Fatalf("invalid version for cloudflare/terraform-provider-cloudflare: %s not found", providerVersion)
	default:
		log.Fatalf("resource list for cloudflare/terraform-provider-cloudflare (v%s) is not fetchable: status code %d", providerVersion, resp.StatusCode)
	}

	var tree struct{ Tree []struct{ Path string } }
	if err := json.NewDecoder(resp.Body).Decode(&tree); err != nil {
		log.Fatalf("failed to decode resource list: %v", err)
	}

	officialResources := make(map[string]struct{})
	for _, item := range tree.Tree {
		if matches := regexp.MustCompile(`^docs/resources/(.+)\.md$`).FindStringSubmatch(item.Path); matches != nil {
			officialResources["cloudflare_"+matches[1]] = struct{}{}
		}
	}

	// Step 2.2 - Check if some resources are missing
	for name := range officialResources {
		if _, ok := resourceList[name]; !ok {
			log.Printf("WARNING: resource '%s' is not describe and will not be generated", name)
		}
	}
	for name := range resourceList {
		if _, ok := officialResources[name]; !ok {
			log.Fatalf("resource '%s' is no more supported by the provider", name)
		}
	}

	// Step 3 - Generate the Go code
	// Step 3.1 - Execute the template with the object
	var buf bytes.Buffer
	if err := tmplProviderConfig.Execute(&buf, resources); err != nil {
		log.Fatalf("failed to generate the Go code: %v", err)
	}

	// Step 3.2 - Remove old configurations files
	info, err := os.Stat(".git")
	if os.IsNotExist(err) || !info.IsDir() {
		log.Fatalf("invalid current directory: this script must be run from the root of the repository")
	}

	entries, err := os.ReadDir("config")
	if err != nil {
		log.Fatalf("invalid 'config' directory: %v", err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			dirPath := path.Join("config", entry.Name())
			if err := os.RemoveAll(dirPath); err != nil {
				log.Fatalf("directory '%s' not removed: %v", dirPath, err)
			}
		}
	}

	// Step 3.2 - Copy each fragment in a separate file
	fragments := bytes.Split(buf.Bytes(), []byte("\n---\n"))
	for _, fragment := range fragments {
		if strings.TrimSpace(string(fragment)) == "" {
			continue
		}

		matches := regexp.MustCompile(`package (.+)\n`).FindStringSubmatch(string(fragment))
		if matches == nil {
			log.Fatalf("invalid package declaration in fragment: %s", fragment)
		}

		err := os.Mkdir(path.Join("config", matches[1]), 0750)
		if err != nil && !os.IsExist(err) {
			log.Fatalf("directory '%s' not created: %v", path.Join("config", matches[1]), err)
		}

		filePath := path.Join("config", matches[1], "config.go")
		if err := os.WriteFile(filePath, fragment, 0600); err != nil {
			log.Fatalf("%s not updated: %v", filePath, err)
		}
		log.Printf("'%s' generated", filePath)
	}

	// Step 3.3 - Generate the external name configuration
	buf.Reset()
	if err := tmplExternalNameConfig.Execute(&buf, resources); err != nil {
		log.Fatalf("failed to generate the external name configuration: %v", err)
	}
	if err := os.WriteFile("config/external_name.go", buf.Bytes(), 0600); err != nil {
		log.Fatalf("config/external_name.go not updated: %v", err)
	}
	log.Println("'config/external_name.go' generated")

	log.Println("All configurations files have been generated")
	log.Println("Please, don't forget to update the 'config/provider.go' file if needed")
}
